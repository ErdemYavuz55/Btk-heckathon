// Minimal p5.js-like animation library
window.p5 = function(sketch) {
  const canvas = document.createElement('canvas');
  let animationId = null;
  
  const p = {
    // Canvas setup
    createCanvas: function(width, height) {
      // Responsive canvas sizing
      const container = canvas.parentElement || document.body;
      const containerWidth = container.offsetWidth || 800;
      const containerHeight = container.offsetHeight || 500;
      
      canvas.width = Math.min(width || containerWidth, containerWidth - 20);
      canvas.height = Math.min(height || 500, containerHeight - 20);
      
      canvas.style.width = '100%';
      canvas.style.height = 'auto';
      canvas.style.maxHeight = '500px';
      canvas.style.border = '2px solid #3b82f6';
      canvas.style.borderRadius = '8px';
      canvas.style.background = '#f8fafc';
      canvas.style.display = 'block';
      return canvas.getContext('2d');
    },
    
    // Animation loop
    loop: function() {
      const animate = () => {
        if (sketch.draw) sketch.draw();
        animationId = requestAnimationFrame(animate);
      };
      animate();
    },
    
    noLoop: function() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    },
    
    // Drawing functions
    background: function(color) {
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = color || '#f8fafc';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    },
    
    fill: function(color) {
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = color || '#3b82f6';
    },
    
    noStroke: function() {
      const ctx = canvas.getContext('2d');
      ctx.strokeStyle = 'transparent';
    },
    
    stroke: function(color) {
      const ctx = canvas.getContext('2d');
      ctx.strokeStyle = color || '#1e40af';
    },
    
    ellipse: function(x, y, width, height) {
      const ctx = canvas.getContext('2d');
      ctx.beginPath();
      ctx.ellipse(x, y, (width || 50)/2, (height || width || 50)/2, 0, 0, 2 * Math.PI);
      ctx.fill();
      if (ctx.strokeStyle !== 'transparent') ctx.stroke();
    },
    
    rect: function(x, y, width, height) {
      const ctx = canvas.getContext('2d');
      ctx.fillRect(x, y, width || 50, height || 50);
      if (ctx.strokeStyle !== 'transparent') ctx.strokeRect(x, y, width || 50, height || 50);
    },
    
    text: function(content, x, y) {
      const ctx = canvas.getContext('2d');
      ctx.font = '14px system-ui, Arial, sans-serif';
      ctx.fillText(content, x || 10, y || 20);
    },
    
    // Educational helpers
    drawVector: function(x, y, vx, vy, scale, color) {
      const ctx = canvas.getContext('2d');
      scale = scale || 10;
      const endX = x + vx * scale;
      const endY = y + vy * scale;
      
      ctx.strokeStyle = color || '#ff4444';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      
      // Arrow head
      const angle = Math.atan2(endY - y, endX - x);
      ctx.beginPath();
      ctx.moveTo(endX, endY);
      ctx.lineTo(endX - 8 * Math.cos(angle - Math.PI/6), endY - 8 * Math.sin(angle - Math.PI/6));
      ctx.lineTo(endX - 8 * Math.cos(angle + Math.PI/6), endY - 8 * Math.sin(angle + Math.PI/6));
      ctx.closePath();
      ctx.fillStyle = color || '#ff4444';
      ctx.fill();
    },
    
    drawInfo: function(info, x, y) {
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.fillRect(x || 10, y || 10, 200, info.length * 20 + 10);
      ctx.strokeStyle = '#333';
      ctx.strokeRect(x || 10, y || 10, 200, info.length * 20 + 10);
      
      ctx.fillStyle = '#333';
      ctx.font = '12px monospace';
      info.forEach((line, i) => {
        ctx.fillText(line, (x || 10) + 5, (y || 10) + 15 + i * 16);
      });
    },
    
    // Math utilities
    random: function(min, max) {
      if (max === undefined) {
        max = min;
        min = 0;
      }
      return Math.random() * (max - min) + min;
    },
    
    map: function(value, start1, stop1, start2, stop2) {
      return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
    },
    
    // Properties updated
    get width() { return canvas.width; },
    get height() { return canvas.height; },
    frameCount: 0
  };
  
  // Auto-increment frame count and draw loop
  let frameAnimationId;
  const animate = () => {
    p.frameCount++;
    if (sketch.draw) {
      sketch.draw.call(p);
    }
    frameAnimationId = requestAnimationFrame(animate);
  };
  
  p.loop = function() {
    if (!frameAnimationId) {
      animate();
    }
  };
  
  p.stop = function() {
    if (frameAnimationId) {
      cancelAnimationFrame(frameAnimationId);
      frameAnimationId = null;
    }
  };
  
  if (sketch.setup) sketch.setup.call(p);
  
  // Instance tracking for cleanup
  const instance = {
    canvas: canvas,
    p5: p,
    mount: function(element) {
      element.appendChild(canvas);
      // Attach instance to element for parameter updates
      element.p5instance = instance;
      p.loop(); // Start animation loop
    },
    remove: function() {
      p.stop(); // Stop animation loop
      if (canvas && canvas.parentNode) {
        canvas.parentNode.removeChild(canvas);
      }
      // Remove from global instances array
      const index = window.p5.instances.indexOf(instance);
      if (index > -1) {
        window.p5.instances.splice(index, 1);
      }
    },
    updateWithNewProps: function(newParams) {
      console.log('üîÑ p5 updateWithNewProps called with:', newParams);
      
      // Store params globally AND on p5 instance
      window.currentParams = newParams;
      p.params = newParams;
      instance.params = newParams;
      
      // Update params if the sketch has an updateParams method
      if (p.updateParams && typeof p.updateParams === 'function') {
        console.log('‚úÖ Using sketch updateParams method');
        try {
          p.updateParams(newParams);
        } catch (updateError) {
          console.error('‚ùå updateParams failed:', updateError);
          // Fallback to redraw
          this.forceRedraw();
        }
      } else {
        console.log('‚ö†Ô∏è No updateParams method, forcing redraw');
        this.forceRedraw();
      }
    },
    forceRedraw: function() {
      // Multiple fallback strategies for redrawing
      try {
        // Strategy 1: Call draw directly with error handling
        if (sketch.draw && typeof sketch.draw === 'function') {
          // Wrap in try-catch to handle undefined errors
          const originalDraw = sketch.draw;
          sketch.draw = function() {
            try {
              originalDraw.call(p);
            } catch (drawError) {
              console.error('‚ùå Draw function error:', drawError);
              // Continue without crashing
            }
          };
          sketch.draw.call(p);
          console.log('‚úÖ Manual draw call successful');
        }
        
        // Strategy 2: Try p5 redraw if available
        if (p.redraw && typeof p.redraw === 'function') {
          p.redraw();
        }
      } catch (error) {
        console.error('‚ùå Force redraw failed:', error);
      }
    }
  };

  // Track instances globally
  window.p5.instances = window.p5.instances || [];
  window.p5.instances.push(instance);

  return instance;
};

console.log('‚úÖ Local p5.js library loaded successfully!'); 